<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>KAIROS | Intelligent Workspace</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Space+Grotesk:wght@500;700&family=JetBrains+Mono:wght@500&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>

    <script>
        const savedTheme = localStorage.getItem('kairosTheme') || 'dark';
        document.documentElement.setAttribute('data-theme', savedTheme);
    </script>

    <style>
        /* --- CORE THEME & RESET --- */
        :root[data-theme="dark"] {
            --bg-main: #000000; --bg-panel: #111111; --border: rgba(255, 255, 255, 0.1);
            --text-primary: #ffffff; --text-secondary: #888888; --surface-hover: rgba(255, 255, 255, 0.08);
            --glass: rgba(17, 17, 17, 0.9); --tile-bg: #1a1a1a; --chat-bubble-me: #222;
            --modal-bg: #1a1a1a; --sheet-bg: #1a1a1a;
        }
        :root[data-theme="light"] {
            --bg-main: #f0f2f5; --bg-panel: #ffffff; --border: rgba(0, 0, 0, 0.1);
            --text-primary: #111827; --text-secondary: #6b7280; --surface-hover: rgba(0, 0, 0, 0.05);
            --glass: rgba(255, 255, 255, 0.9); --tile-bg: #222; --chat-bubble-me: #e5e7eb;
            --modal-bg: #ffffff; --sheet-bg: #ffffff;
        }
        :root {
            --accent: #10b981; --ai-blue: #3b82f6; --danger: #ef4444; --warning: #f59e0b;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; outline: none; -webkit-tap-highlight-color: transparent; }
        body { background-color: var(--bg-main); color: var(--text-primary); font-family: 'Inter', sans-serif; height: 100vh; overflow: hidden; display: flex; flex-direction: column; transition: background 0.3s; }

        /* --- LAYOUT --- */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-thumb { background: rgba(125, 125, 125, 0.2); border-radius: 10px; }
        
        header {
            height: 60px; padding: 0 20px; display: flex; justify-content: space-between; align-items: center;
            border-bottom: 1px solid var(--border); background: var(--bg-panel); z-index: 10;
        }
        .meeting-info h1 { font-family: 'Space Grotesk'; font-size: 16px; font-weight: 700; cursor: text; border-bottom: 1px dashed transparent; transition: 0.2s; }
        .meeting-info h1:hover, .meeting-info h1:focus { border-bottom-color: var(--text-secondary); }
        
        .rec-badge { 
            display: flex; align-items: center; gap: 6px; font-size: 11px; padding: 4px 10px; border-radius: 20px; 
            background: rgba(125,125,125,0.1); color: var(--text-secondary); cursor: pointer; transition: 0.3s;
        }
        .rec-badge.active { background: linear-gradient(135deg, var(--ai-blue), var(--accent)); color: #fff; font-weight: 600; box-shadow: 0 0 10px rgba(59, 130, 246, 0.3); }

        .stage-container { flex: 1; display: flex; overflow: hidden; position: relative; }
        
        /* --- VIDEO GRID --- */
        .video-grid {
            flex: 1; padding: 16px; display: grid; gap: 12px;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            grid-auto-rows: minmax(200px, 1fr);
            align-content: center; overflow-y: auto;
        }
        .video-tile {
            background: var(--tile-bg); border-radius: 12px; position: relative; overflow: hidden;
            border: 2px solid transparent; display: flex; align-items: center; justify-content: center;
            transition: all 0.2s ease;
        }
        /* DYNAMIC SPEAKING INDICATOR */
        .video-tile.speaking { border-color: var(--accent); box-shadow: 0 0 20px rgba(16,185,129,0.2); }
        
        .live-video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); background: #000; }
        
        .tile-avatar { width: 80px; height: 80px; border-radius: 50%; background: #333; display: flex; align-items: center; justify-content: center; font-weight: 700; color: #fff; font-size: 24px; box-shadow: 0 4px 10px rgba(0,0,0,0.3); position: absolute; z-index: 2; }
        
        .tile-overlay { position: absolute; bottom: 12px; left: 12px; right: 12px; display: flex; justify-content: space-between; align-items: flex-end; z-index: 5; pointer-events: none; }
        .user-nametag { background: rgba(0,0,0,0.6); backdrop-filter: blur(4px); padding: 6px 10px; border-radius: 6px; font-size: 13px; font-weight: 500; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.5); }
        
        /* FOCUS MONITOR */
        .attention-metric { background: rgba(0,0,0,0.6); backdrop-filter: blur(4px); padding: 4px 8px; border-radius: 6px; display: flex; flex-direction: column; gap: 3px; min-width: 60px; }
        .att-label { font-size: 9px; color: #ccc; text-transform: uppercase; font-weight: 700; }
        .att-bar { width: 100%; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; overflow: hidden; }
        .att-fill { height: 100%; background: var(--accent); width: 0%; transition: width 0.5s ease; }

        /* --- SIDEBAR --- */
        .sidebar { width: 340px; background: var(--bg-panel); border-left: 1px solid var(--border); display: flex; flex-direction: column; transition: 0.3s; position: relative; z-index: 60; transform: translateX(0); }
        .sidebar.collapsed { width: 0; border: none; overflow: hidden; }
        .sidebar-tabs { display: flex; border-bottom: 1px solid var(--border); }
        .tab-btn { flex: 1; padding: 14px; font-size: 12px; font-weight: 600; color: var(--text-secondary); cursor: pointer; text-align: center; border-bottom: 2px solid transparent; transition: 0.2s; }
        .tab-btn:hover { background: var(--surface-hover); }
        .tab-btn.active { color: var(--accent); border-bottom-color: var(--accent); background: rgba(16,185,129,0.05); }
        .sidebar-content { flex: 1; overflow-y: auto; padding: 16px; display: none; }
        .sidebar-content.active { display: flex; flex-direction: column; }

        /* AGENDA STYLES */
        .agenda-input-group { display: flex; gap: 8px; margin-bottom: 16px; }
        .agenda-input { flex: 1; background: var(--surface-hover); border: 1px solid var(--border); padding: 10px; border-radius: 8px; color: var(--text-primary); font-size: 13px; transition: 0.2s; }
        .agenda-input:focus { border-color: var(--accent); }
        .add-btn { background: var(--accent); color: #000; border: none; border-radius: 8px; width: 36px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: 0.2s; }
        .add-btn:hover { filter: brightness(1.1); }
        
        .agenda-item { display: flex; gap: 12px; padding: 12px; border-radius: 8px; margin-bottom: 8px; align-items: flex-start; cursor: pointer; transition: 0.2s; border: 1px solid transparent; background: rgba(255,255,255,0.02); }
        .agenda-item:hover { background: var(--surface-hover); border-color: var(--border); }
        .agenda-item.ai-detected { background: rgba(16,185,129,0.1); border-color: var(--accent); animation: pulse-green 2s infinite; }
        
        @keyframes pulse-green { 0% { border-color: var(--accent); } 50% { border-color: transparent; } 100% { border-color: var(--accent); } }

        .chk-box { width: 18px; height: 18px; border: 1px solid var(--text-secondary); border-radius: 5px; display: flex; align-items: center; justify-content: center; color: transparent; flex-shrink: 0; transition: 0.2s; }
        .chk-box.checked { background: var(--accent); border-color: var(--accent); color: #000; }
        .agenda-text { font-size: 13px; line-height: 1.4; font-weight: 500; flex: 1; }
        .agenda-text.done { text-decoration: line-through; color: var(--text-secondary); }

        /* POLL STYLES */
        .poll-card { background: var(--surface-hover); border-radius: 12px; padding: 16px; margin-bottom: 16px; border: 1px solid var(--border); }
        .poll-question { font-weight: 600; font-size: 14px; margin-bottom: 12px; }
        .poll-option { display: flex; justify-content: space-between; align-items: center; padding: 8px 0; font-size: 13px; cursor: pointer; position: relative; }
        .poll-bar-bg { position: absolute; left: 0; top: 4px; bottom: 4px; background: rgba(16,185,129,0.1); border-radius: 4px; z-index: 0; transition: width 0.3s; }
        .poll-meta { font-size: 11px; color: var(--text-secondary); margin-top: 8px; display: flex; justify-content: space-between; }

        /* TRANSCRIPT STYLES */
        .transcript-entry { margin-bottom: 16px; font-size: 13px; border-left: 2px solid transparent; padding-left: 10px; animation: fade-in 0.3s ease; }
        .transcript-entry.highlight { border-left-color: var(--accent); }
        .ts-meta { display: flex; justify-content: space-between; margin-bottom: 4px; color: var(--text-secondary); font-size: 11px; font-family: 'JetBrains Mono'; }
        .ts-text { color: var(--text-secondary); line-height: 1.6; }
        @keyframes fade-in { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

        /* CONTROLS */
        .control-bar { height: 70px; display: flex; justify-content: center; align-items: center; gap: 12px; position: absolute; bottom: 24px; left: 50%; transform: translateX(-50%); background: var(--glass); backdrop-filter: blur(16px); padding: 0 16px; border-radius: 24px; border: 1px solid rgba(125,125,125,0.2); z-index: 50; box-shadow: 0 20px 40px rgba(0,0,0,0.4); }
        .ctrl-btn { width: 44px; height: 44px; border-radius: 14px; background: #333; color: #fff; display: flex; align-items: center; justify-content: center; font-size: 20px; cursor: pointer; transition: 0.2s; position: relative; }
        .ctrl-btn:hover { background: #444; transform: translateY(-2px); }
        .ctrl-btn.active { background: var(--accent); color: #000; }
        .ctrl-btn.danger { background: var(--danger); }

        /* CAPTIONS OVERLAY */
        #captionsOverlay { position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); backdrop-filter: blur(8px); padding: 16px 24px; border-radius: 16px; color: #fff; font-size: 16px; font-weight: 500; text-align: center; max-width: 70%; display: none; z-index: 40; pointer-events: none; transition: 0.2s; box-shadow: 0 10px 30px rgba(0,0,0,0.3); }
        #captionsOverlay.active { display: block; animation: pop-up 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        @keyframes pop-up { from { transform: translateX(-50%) scale(0.9); opacity: 0; } to { transform: translateX(-50%) scale(1); opacity: 1; } }

        /* MODALS */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 3000; display: none; align-items: center; justify-content: center; backdrop-filter: blur(8px); opacity: 0; transition: opacity 0.3s; }
        .modal-overlay.visible { opacity: 1; }
        .modal-box { background: var(--modal-bg); border: 1px solid var(--border); padding: 30px; border-radius: 20px; width: 500px; box-shadow: 0 30px 60px rgba(0,0,0,0.5); max-height: 90vh; display: flex; flex-direction: column; }
        
        .summary-list { margin-top: 15px; font-size: 14px; color: var(--text-secondary); overflow-y: auto; flex: 1; padding-right: 8px; }
        .summary-block { margin-bottom: 16px; background: var(--surface-hover); padding: 12px; border-radius: 8px; border-left: 3px solid var(--accent); }
        .summary-title { font-weight: 700; color: var(--text-primary); margin-bottom: 6px; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px; }
        .summary-item { margin-bottom: 4px; display: flex; gap: 8px; line-height: 1.5; }
        .summary-bullet { color: var(--accent); font-weight: bold; }

        @media (max-width: 768px) {
            .stage-container { flex-direction: column; }
            .sidebar { position: fixed; width: 100%; height: 100%; transform: translateY(100%); }
            .sidebar.active-mobile { transform: translateY(0); }
            .control-bar { width: 90%; height: 60px; bottom: 20px; }
        }
    </style>
</head>
<body>

<header>
    <div class="meeting-info">
        <h1 id="meetingTitle" contenteditable="true" onblur="broadcastTitleUpdate()">Design Sync: Q1 Roadmap</h1>
        <div style="font-size: 11px; color: var(--text-secondary); margin-top: 2px;">
            <span id="participantCount">1</span> Participants • <span id="timer" style="font-family:'JetBrains Mono'">00:00:00</span>
        </div>
    </div>
    <div class="rec-badge active" id="aiStatus" onclick="toggleAI()">
        <i class="ph-fill ph-sparkle"></i> <span>AI Active</span>
    </div>
</header>

<div class="stage-container">
    <div class="video-grid" id="videoGrid">
        <!-- Dynamic Tiles Inserted Here -->
    </div>

    <div id="captionsOverlay">
        <div id="captionSpeaker" style="font-size:12px; opacity:0.8; margin-bottom:4px; color:var(--accent); font-weight:600;"></div>
        <span id="captionText"></span>
    </div>

    <div class="sidebar" id="sidebar">
        <div class="sidebar-tabs">
            <div class="tab-btn active" onclick="switchTab('agenda')">Agenda</div>
            <div class="tab-btn" onclick="switchTab('polls')">Polls</div>
            <div class="tab-btn" onclick="switchTab('notes')">AI Notes</div>
            <div class="tab-btn" onclick="switchTab('chat')">Chat</div>
        </div>

        <div id="tab-agenda" class="sidebar-content active">
            <div class="agenda-input-group">
                <input type="text" id="newAgendaInput" class="agenda-input" placeholder="Add agenda item..." onkeypress="handleAgendaInput(event)">
                <button class="add-btn" onclick="addAgendaItem()"><i class="ph-bold ph-plus"></i></button>
            </div>
            <div id="agendaList"></div>
        </div>

        <div id="tab-polls" class="sidebar-content" style="display:none;">
             <div class="agenda-input-group">
                <input type="text" id="newPollInput" class="agenda-input" placeholder="Create a poll..." onkeypress="handlePollInput(event)">
                <button class="add-btn" onclick="createPoll()"><i class="ph-bold ph-plus"></i></button>
            </div>
            <div id="pollList"></div>
        </div>

        <div id="tab-notes" class="sidebar-content" style="display:none;">
            <div style="font-size:10px; color:var(--text-secondary); margin-bottom:10px; text-align:center; text-transform:uppercase; letter-spacing:1px; font-weight:700;">Live Transcript</div>
            <div id="transcriptFeed"></div>
        </div>

        <div id="tab-chat" class="sidebar-content" style="display:none;">
            <div style="flex:1; overflow-y:auto; padding-bottom:10px;" id="chatFeed"></div>
            <div style="margin-top:auto; display:flex; gap:8px;">
                <input type="text" id="chatInput" class="agenda-input" placeholder="Message everyone..." onkeypress="handleChat(event)">
                <button class="add-btn" onclick="sendChat()" style="width:40px;"><i class="ph-fill ph-paper-plane-right"></i></button>
            </div>
        </div>
    </div>
</div>

<div class="control-bar">
    <div class="ctrl-btn" id="micBtn" onclick="toggleMic()"><i class="ph-fill ph-microphone"></i></div>
    <div class="ctrl-btn" id="camBtn" onclick="toggleCam()"><i class="ph-fill ph-video-camera"></i></div>
    <div class="ctrl-btn" onclick="toggleCaptions()" id="captionBtn"><i class="ph-bold ph-closed-captioning"></i></div>
    <div class="ctrl-btn" onclick="toggleSidebar()"><i class="ph-bold ph-sidebar-simple"></i></div>
    <div class="ctrl-btn danger" onclick="endMeeting()"><i class="ph-bold ph-phone-disconnect"></i></div>
</div>

<div class="modal-overlay" id="endModal">
    <div class="modal-box">
        <div style="text-align:center;">
            <i class="ph-duotone ph-check-circle" style="font-size: 56px; color: var(--accent); margin-bottom: 16px;"></i>
            <h2 style="font-family:'Space Grotesk'; margin-bottom:8px;">Meeting Ended</h2>
            <p style="font-size:13px; color:var(--text-secondary);">An AI-generated summary has been emailed to all participants.</p>
        </div>
        
        <div style="margin:20px 0; flex:1; overflow:hidden; display:flex; flex-direction:column;">
            <div class="summary-list" id="aiSummaryContent">
                <!-- AI Summary Injected Here -->
            </div>
        </div>

        <button onclick="location.reload()" style="width:100%; padding:14px; background:var(--text-primary); color:var(--bg-main); border:none; border-radius:12px; font-weight:600; cursor:pointer; font-size:14px;">
            Close & Start New
        </button>
    </div>
</div>

<script>
    /**
     * KAIROS CORE: WEBRTC & SOCKET ARCHITECTURE
     * Implements a Serverless Mesh Network using BroadcastChannel for signaling.
     * Mocks a Socket.IO interface to maintain standard event-driven architecture.
     */

    // --- MOCK SOCKET.IO INTERFACE ---
    // Simulates a socket server using BroadcastChannel for signaling between tabs
    class MockSocket {
        constructor() {
            this.bus = new BroadcastChannel('kairos_v4_signaling');
            this.listeners = {};
            this.id = sessionStorage.getItem('kairos_id') || crypto.randomUUID();
            sessionStorage.setItem('kairos_id', this.id);
            
            this.bus.onmessage = (e) => {
                const { event, data, senderId } = e.data;
                if (senderId === this.id) return; // Ignore self
                if (this.listeners[event]) {
                    this.listeners[event].forEach(cb => cb(data, senderId));
                }
            };
        }

        on(event, callback) {
            if (!this.listeners[event]) this.listeners[event] = [];
            this.listeners[event].push(callback);
        }

        emit(event, data) {
            this.bus.postMessage({ event, data, senderId: this.id });
        }
    }
    
    // Initialize "Socket"
    const socket = new MockSocket();
    const myId = socket.id;

    // --- IDENTITY & STATE ---
    let myName = sessionStorage.getItem('kairos_name');
    if (!myName) {
        myName = prompt("Enter your name to join:", "Guest " + Math.floor(Math.random()*100));
        if (!myName) myName = "Guest " + Math.floor(Math.random()*1000);
    }
    sessionStorage.setItem('kairos_name', myName);

    const state = {
        me: { id: myId, name: myName, speaking: false, focusScore: 0, cam: false, mic: false },
        participants: {}, // Map<id, {info, stream}>
        agenda: [
            { id: 1, text: "Review Q1 Roadmap", done: false, keywords: ["roadmap", "q1", "review", "plan"] },
            { id: 2, text: "Approve Budget", done: false, keywords: ["budget", "money", "cost", "approve", "finance"] },
            { id: 3, text: "Discuss Tech Stack", done: false, keywords: ["tech stack", "react", "nextjs", "database", "code"] }
        ],
        polls: [],
        transcript: [],
        isAiActive: true,
        captionsEnabled: true
    };
    
    state.participants[myId] = { info: state.me, stream: null };

    // --- WEBRTC CONFIGURATION ---
    const rtcConfig = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
        ]
    };
    const peers = {}; // Map<peerId, RTCPeerConnection>
    let localStream = null;

    // --- INITIALIZATION ---
    document.addEventListener('DOMContentLoaded', async () => {
        // Start Local Media
        try {
            localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
            state.participants[myId].stream = localStream;
            
            // Mute local audio feedback
            localStream.getAudioTracks()[0].enabled = false; 
            localStream.getVideoTracks()[0].enabled = false;
        } catch(e) {
            console.warn("Media devices not found, starting without media", e);
        }
        
        renderParticipants();
        renderAgenda();
        startTimer();
        initAudioAnalysis();
        initSpeechRecognition();
        
        // Announce presence via Socket
        socket.emit('join', state.me);
        
        document.title = "KAIROS | " + document.getElementById('meetingTitle').innerText;
    });

    // --- SOCKET EVENT HANDLERS (SIGNALING) ---
    
    // 1. Peer Joins
    socket.on('join', async (peerInfo, senderId) => {
        if(!state.participants[senderId]) {
            showToast(`${peerInfo.name} joined`);
            addPeerToState(peerInfo);
            
            // Create Peer Connection (Initiator)
            const pc = createPeerConnection(senderId);
            
            // Add local tracks
            if(localStream) {
                localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
            }
            
            // Create Offer
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            
            socket.emit('signal', { target: senderId, type: 'offer', sdp: offer });
            
            // Sync State (Host/Older peer responsibility)
            socket.emit('sync_state', { 
                target: senderId,
                participants: Object.keys(state.participants).map(k => state.participants[k].info),
                agenda: state.agenda,
                polls: state.polls,
                title: document.getElementById('meetingTitle').innerText
            });
        }
    });

    // 2. WebRTC Signaling (Offer/Answer/Candidate)
    socket.on('signal', async (data, senderId) => {
        if (data.target && data.target !== myId) return; // Ignore if not for me

        let pc = peers[senderId];
        if (!pc) {
             pc = createPeerConnection(senderId);
             if(localStream) {
                localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
             }
        }

        if (data.type === 'offer') {
            await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            socket.emit('signal', { target: senderId, type: 'answer', sdp: answer });
        } else if (data.type === 'answer') {
            await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
        } else if (data.type === 'candidate') {
            if (data.candidate) {
                await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
            }
        }
    });

    // 3. State Synchronization
    socket.on('sync_state', (data) => {
        if(data.target && data.target !== myId) return;
        
        // Merge Participants
        data.participants.forEach(p => {
            if(p.id !== myId) addPeerToState(p);
        });
        
        state.agenda = data.agenda;
        state.polls = data.polls;
        document.getElementById('meetingTitle').innerText = data.title;
        renderParticipants();
        renderAgenda();
        renderPolls();
    });

    // 4. Updates & Chat
    socket.on('update_peer', (info) => {
        if(state.participants[info.id]) {
            state.participants[info.id].info = { ...state.participants[info.id].info, ...info };
            renderParticipants();
        }
    });

    socket.on('chat', (data) => addChatMessage(data.sender, data.text, false));
    socket.on('transcript', (data) => handleRemoteTranscript(data));
    socket.on('agenda_update', (data) => { state.agenda = data; renderAgenda(); });
    socket.on('poll_update', (data) => { state.polls = data; renderPolls(); });
    socket.on('title_update', (data) => { document.getElementById('meetingTitle').innerText = data; });

    // --- WEBRTC FUNCTIONS ---
    function createPeerConnection(peerId) {
        const pc = new RTCPeerConnection(rtcConfig);
        peers[peerId] = pc;

        pc.onicecandidate = (event) => {
            if (event.candidate) {
                socket.emit('signal', { target: peerId, type: 'candidate', candidate: event.candidate });
            }
        };

        pc.ontrack = (event) => {
            // Received remote stream
            if (state.participants[peerId]) {
                state.participants[peerId].stream = event.streams[0];
                renderParticipants();
            }
        };
        
        return pc;
    }

    function addPeerToState(info) {
        if(!state.participants[info.id]) {
            state.participants[info.id] = { info: info, stream: null };
            renderParticipants();
        }
    }

    // --- PARTICIPANT UI LOGIC (EFFICIENT UPDATE) ---
    function renderParticipants() {
        const grid = document.getElementById('videoGrid');
        const list = Object.values(state.participants);
        document.getElementById('participantCount').innerText = list.length;

        list.forEach(pData => {
            const p = pData.info;
            const isMe = p.id === myId;
            let tile = document.getElementById(`tile-${p.id}`);
            
            const initials = (p.name || "GU").split(' ').map(n=>n[0]).join('').substring(0,2).toUpperCase();
            const avatarBg = stringToColor(p.name);

            if (!tile) {
                // CREATE TILE
                tile = document.createElement('div');
                tile.className = `video-tile ${p.speaking ? 'speaking' : ''}`;
                tile.id = `tile-${p.id}`;
                
                tile.innerHTML = `
                    <div class="tile-avatar" style="background:${avatarBg}">${initials}</div>
                    <video class="live-video" id="video-${p.id}" autoplay playsinline muted></video>
                    <div class="tile-overlay">
                        <div class="user-nametag">${p.name} ${isMe ? '(You)' : ''}</div>
                        <div class="attention-metric">
                            <div class="att-label">Contribution</div>
                            <div class="att-bar"><div class="att-fill" style="width: ${p.focusScore}%"></div></div>
                        </div>
                    </div>
                `;
                grid.appendChild(tile);
            } else {
                // UPDATE TILE
                if (p.speaking) tile.classList.add('speaking');
                else tile.classList.remove('speaking');
                const bar = tile.querySelector('.att-fill');
                if(bar) bar.style.width = `${p.focusScore}%`;
            }

            // STREAM HANDLING
            const videoEl = document.getElementById(`video-${p.id}`);
            const avatarEl = tile.querySelector('.tile-avatar');
            
            if (videoEl) {
                if (isMe) {
                    // Local Stream
                    if (localStream && videoEl.srcObject !== localStream) videoEl.srcObject = localStream;
                    videoEl.style.display = p.cam ? 'block' : 'none';
                    videoEl.muted = true; // Always mute self
                } else {
                    // Remote Stream
                    if (pData.stream && videoEl.srcObject !== pData.stream) videoEl.srcObject = pData.stream;
                    videoEl.style.display = (p.cam && pData.stream) ? 'block' : 'none';
                    videoEl.muted = false; // Hear others
                }
                
                // Toggle Avatar based on video visibility
                avatarEl.style.display = (videoEl.style.display === 'block') ? 'none' : 'flex';
            }
        });
    }

    // --- AUDIO & SPEAKING DETECTION ---
    let audioCtx, analyser;
    
    async function initAudioAnalysis() {
        if(!localStream) return;
        try {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioCtx.createAnalyser();
            const source = audioCtx.createMediaStreamSource(localStream);
            source.connect(analyser);
            analyser.fftSize = 512;
            checkAudioLevel();
        } catch (err) {
            console.error("Audio Analysis failed", err);
        }
    }

    let lastFocusUpdate = 0;

    function checkAudioLevel() {
        if(!analyser || !state.me.mic) {
            if(state.me.speaking) updateMyStatus({ speaking: false });
            requestAnimationFrame(checkAudioLevel);
            return;
        }

        const dataArray = new Uint8Array(analyser.frequencyBinCount);
        analyser.getByteFrequencyData(dataArray);
        const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
        const isSpeaking = average > 25; 
        
        if (state.me.speaking !== isSpeaking) {
            updateMyStatus({ speaking: isSpeaking });
        }

        if (isSpeaking) {
            state.me.focusScore = Math.min(100, state.me.focusScore + 0.05);
            if (Date.now() - lastFocusUpdate > 1000) {
                updateMyStatus({ focusScore: state.me.focusScore });
                lastFocusUpdate = Date.now();
            }
        }
        requestAnimationFrame(checkAudioLevel);
    }

    function updateMyStatus(updates) {
        state.me = { ...state.me, ...updates };
        state.participants[myId].info = state.me;
        socket.emit('update_peer', state.me);
        renderParticipants();
    }

    function toggleMic() {
        state.me.mic = !state.me.mic;
        document.getElementById('micBtn').classList.toggle('active', !state.me.mic);
        document.getElementById('micBtn').innerHTML = state.me.mic ? '<i class="ph-fill ph-microphone"></i>' : '<i class="ph-fill ph-microphone-slash"></i>';
        updateMyStatus({ mic: state.me.mic });
        
        if(localStream) localStream.getAudioTracks()[0].enabled = state.me.mic;
    }

    function toggleCam() {
        state.me.cam = !state.me.cam;
        document.getElementById('camBtn').classList.toggle('active', !state.me.cam);
        document.getElementById('camBtn').innerHTML = state.me.cam ? '<i class="ph-fill ph-video-camera"></i>' : '<i class="ph-fill ph-video-camera-slash"></i>';
        updateMyStatus({ cam: state.me.cam });
        
        if(localStream) localStream.getVideoTracks()[0].enabled = state.me.cam;
        renderParticipants(); // Trigger re-render to toggle video/avatar
    }

    // --- AI TRANSCRIPTION & AGENDA LOGIC ---
    function initSpeechRecognition() {
        if (!('webkitSpeechRecognition' in window)) return;
        const recognition = new webkitSpeechRecognition();
        recognition.continuous = true;
        recognition.interimResults = true;
        recognition.lang = 'en-US';

        recognition.onresult = (event) => {
            if(!state.me.mic) return;

            let interim = '';
            for (let i = event.resultIndex; i < event.results.length; ++i) {
                if (event.results[i].isFinal) {
                    const text = event.results[i][0].transcript;
                    handleTranscriptEvent(state.me.name, text, true);
                    socket.emit('transcript', { sender: state.me.name, text: text, isFinal: true });
                } else {
                    interim += event.results[i][0].transcript;
                }
            }
            if(interim) {
                showCaptions(state.me.name, interim);
                socket.emit('transcript', { sender: state.me.name, text: interim, isFinal: false });
            }
        };
        recognition.start();
    }

    function handleRemoteTranscript(data) {
        if(data.isFinal) handleTranscriptEvent(data.sender, data.text, false);
        else showCaptions(data.sender, data.text);
    }

    function handleTranscriptEvent(user, text, isLocal) {
        const entry = { user, text, time: new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}) };
        state.transcript.push(entry);
        updateTranscriptUI(entry);

        if (state.isAiActive) analyzeTextForAgenda(text);
    }

    function analyzeTextForAgenda(text) {
        let changed = false;
        const lowerText = text.toLowerCase();
        
        state.agenda.forEach(item => {
            if(!item.done && item.keywords.some(k => lowerText.includes(k))) {
                item.done = true;
                changed = true;
                showToast(`AI: Agenda "${item.text}" marked complete.`);
                setTimeout(() => {
                    const el = document.querySelectorAll('.agenda-item')[state.agenda.indexOf(item)];
                    if(el) el.classList.add('ai-detected');
                }, 100);
            }
        });

        if(changed) {
            renderAgenda();
            socket.emit('agenda_update', state.agenda);
        }
    }

    function showCaptions(speaker, text) {
        if(!state.captionsEnabled) return;
        const overlay = document.getElementById('captionsOverlay');
        document.getElementById('captionSpeaker').innerText = speaker;
        document.getElementById('captionText').innerText = text;
        overlay.classList.add('active');
        clearTimeout(window.captionTimeout);
        window.captionTimeout = setTimeout(() => overlay.classList.remove('active'), 4000);
    }

    function updateTranscriptUI(entry) {
        const feed = document.getElementById('transcriptFeed');
        const el = document.createElement('div');
        el.className = 'transcript-entry highlight';
        el.innerHTML = `<div class="ts-meta"><span>${entry.user}</span> <span>${entry.time}</span></div><div class="ts-text">${entry.text}</div>`;
        feed.appendChild(el);
        feed.scrollTop = feed.scrollHeight;
    }

    // --- AGENDA & POLLS ---
    function renderAgenda() {
        const list = document.getElementById('agendaList');
        list.innerHTML = '';
        state.agenda.forEach(item => {
            const el = document.createElement('div');
            el.className = `agenda-item ${item.done ? 'done' : ''}`;
            el.onclick = () => toggleAgendaManual(item.id);
            el.innerHTML = `
                <div class="chk-box ${item.done ? 'checked' : ''}"><i class="ph-bold ph-check"></i></div>
                <div class="agenda-text ${item.done ? 'done' : ''}">${item.text}</div>
            `;
            list.appendChild(el);
        });
    }

    function addAgendaItem() {
        const input = document.getElementById('newAgendaInput');
        if(!input.value.trim()) return;
        const newItem = { id: Date.now(), text: input.value, done: false, keywords: input.value.toLowerCase().split(' ') };
        state.agenda.push(newItem);
        input.value = '';
        renderAgenda();
        socket.emit('agenda_update', state.agenda);
    }

    function handleAgendaInput(e) { if(e.key === 'Enter') addAgendaItem(); }
    
    function toggleAgendaManual(id) {
        const item = state.agenda.find(i => i.id === id);
        if(item) {
            item.done = !item.done;
            renderAgenda();
            socket.emit('agenda_update', state.agenda);
        }
    }

    // POLLS LOGIC
    function renderPolls() {
        const list = document.getElementById('pollList');
        list.innerHTML = '';
        state.polls.forEach((poll, index) => {
            const el = document.createElement('div');
            el.className = 'poll-card';
            let html = `<div class="poll-question">${poll.question}</div>`;
            poll.options.forEach((opt, optIndex) => {
                const pct = poll.total > 0 ? Math.round((opt.votes / poll.total) * 100) : 0;
                html += `
                    <div class="poll-option" onclick="votePoll(${index}, ${optIndex})">
                        <div class="poll-bar-bg" style="width:${pct}%"></div>
                        <span style="position:relative; z-index:1;">${opt.text}</span>
                        <span style="position:relative; z-index:1; font-weight:600;">${pct}%</span>
                    </div>
                `;
            });
            html += `<div class="poll-meta"><span>${poll.total} votes</span> <span>${poll.active ? 'Live' : 'Closed'}</span></div>`;
            el.innerHTML = html;
            list.appendChild(el);
        });
    }

    function createPoll() {
        const input = document.getElementById('newPollInput');
        const txt = input.value.trim();
        if(!txt) return;
        let parts = txt.split('?');
        let question = parts[0] + '?';
        let options = parts[1] ? parts[1].split(',').map(s => s.trim()) : ['Yes', 'No'];
        const newPoll = { question, options: options.map(o => ({ text: o, votes: 0 })), total: 0, active: true };
        state.polls.unshift(newPoll);
        input.value = '';
        renderPolls();
        socket.emit('poll_update', state.polls);
    }
    
    function handlePollInput(e) { if(e.key === 'Enter') createPoll(); }

    function votePoll(pollIndex, optIndex) {
        const poll = state.polls[pollIndex];
        poll.options[optIndex].votes++;
        poll.total++;
        renderPolls();
        socket.emit('poll_update', state.polls);
    }

    // --- CHAT ---
    function handleChat(e) { if(e.key === 'Enter') sendChat(); }
    function sendChat() {
        const input = document.getElementById('chatInput');
        if(!input.value.trim()) return;
        addChatMessage(state.me.name, input.value, true);
        socket.emit('chat', { sender: state.me.name, text: input.value });
        input.value = '';
    }
    function addChatMessage(sender, text, isMe) {
        const feed = document.getElementById('chatFeed');
        const msg = document.createElement('div');
        msg.style.marginBottom = "10px";
        msg.innerHTML = `
            <div style="font-size:10px; color:var(--text-secondary); margin-bottom:2px;">${sender}</div>
            <div style="background:${isMe ? 'var(--accent)' : 'var(--chat-bubble-me)'}; color:${isMe ? '#000' : 'var(--text-primary)'}; padding:8px 12px; border-radius:8px; display:inline-block; font-size:13px; font-weight:500;">${text}</div>
        `;
        feed.appendChild(msg);
        feed.scrollTop = feed.scrollHeight;
    }

    // --- UTILS ---
    function broadcastTitleUpdate() {
        const t = document.getElementById('meetingTitle').innerText;
        document.title = "KAIROS | " + t;
        socket.emit('title_update', t);
    }

    function switchTab(tab) {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.sidebar-content').forEach(c => c.classList.remove('active'));
        document.querySelectorAll('.sidebar-content').forEach(c => c.style.display = 'none');
        const btn = Array.from(document.querySelectorAll('.tab-btn')).find(b => b.innerText.toLowerCase().includes(tab.split(' ')[0]));
        if(btn) btn.classList.add('active');
        const content = document.getElementById(`tab-${tab}`);
        content.style.display = 'flex';
        setTimeout(() => content.classList.add('active'), 10);
    }

    function toggleSidebar() { document.getElementById('sidebar').classList.toggle('collapsed'); }
    function toggleCaptions() { 
        state.captionsEnabled = !state.captionsEnabled; 
        document.getElementById('captionBtn').classList.toggle('active', state.captionsEnabled);
    }
    function toggleAI() { 
        state.isAiActive = !state.isAiActive;
        const badge = document.getElementById('aiStatus');
        badge.innerHTML = state.isAiActive ? '<i class="ph-fill ph-sparkle"></i> <span>AI Active</span>' : '<i class="ph-fill ph-pause"></i> <span>AI Paused</span>';
        badge.classList.toggle('active', state.isAiActive);
    }

    function startTimer() {
        let sec = 0;
        setInterval(() => {
            sec++;
            const h = Math.floor(sec/3600).toString().padStart(2,'0');
            const m = Math.floor((sec%3600)/60).toString().padStart(2,'0');
            const s = (sec%60).toString().padStart(2,'0');
            document.getElementById('timer').innerText = `${h}:${m}:${s}`;
        }, 1000);
    }

    function stringToColor(str) {
        if (!str) return '#333';
        let hash = 0;
        for (let i = 0; i < str.length; i++) hash = str.charCodeAt(i) + ((hash << 5) - hash);
        const c = (hash & 0x00FFFFFF).toString(16).toUpperCase();
        return '#' + "00000".substring(0, 6 - c.length) + c;
    }

    function showToast(msg) {
        const t = document.createElement('div');
        t.innerHTML = `<i class="ph-fill ph-info"></i> ${msg}`;
        t.style.cssText = "position:fixed; top:80px; left:50%; transform:translateX(-50%); background:var(--bg-panel); color:var(--text-primary); padding:10px 20px; border-radius:30px; border:1px solid var(--border); z-index:9999; box-shadow:0 10px 30px rgba(0,0,0,0.5); font-size:12px; font-weight:500; display:flex; align-items:center; gap:8px;";
        document.body.appendChild(t);
        setTimeout(() => t.remove(), 3000);
    }

    // --- END MEETING INTELLIGENCE ---
    function endMeeting() {
        const container = document.getElementById('aiSummaryContent');
        container.innerHTML = '';
        
        let decisions = [];
        let actions = [];
        
        state.transcript.forEach(t => {
            const txt = t.text.toLowerCase();
            if (txt.includes("agree") || txt.includes("decided") || txt.includes("approved")) decisions.push(t.text);
            else if (txt.includes("will") || txt.includes("task") || txt.includes("todo")) actions.push(t.text);
        });

        const createBlock = (title, items, icon) => {
            if(items.length === 0) return '';
            return `<div class="summary-block"><div class="summary-title"><i class="ph-bold ${icon}"></i> ${title}</div>${items.slice(0, 4).map(i => `<div class="summary-item"><span class="summary-bullet">•</span> ${i}</div>`).join('')}</div>`;
        };

        let html = '';
        html += createBlock('Decisions Made', decisions, 'ph-check-circle');
        html += createBlock('Action Items', actions, 'ph-list-checks');
        const doneAgenda = state.agenda.filter(a => a.done).map(a => a.text);
        html += createBlock('Completed Agenda', doneAgenda, 'ph-calendar-check');
        
        if (html === '') html = `<div class="summary-block"><div class="summary-item">No significant discussion points detected.</div></div>`;

        container.innerHTML = html;
        const modal = document.getElementById('endModal');
        modal.style.display = 'flex';
        setTimeout(() => modal.classList.add('visible'), 10);
    }
</script>
</body>
</html>
